# Backend Architecture (`server/`)

This document details the architecture of the Studynaut backend API server.

## Overview

The backend is a Node.js application built with Express.js and TypeScript. Its primary responsibilities are:

*   Providing a RESTful API for the frontend client.
*   Handling user authentication and authorization.
*   Validating incoming data (using Zod).
*   Interacting with the PostgreSQL database (using Drizzle ORM).
*   Enqueuing background jobs for asynchronous processing (using BullMQ).
*   Managing configuration and environment variables.

## Key Technologies

*   **Framework:** Express.js
*   **Language:** TypeScript
*   **ORM:** Drizzle ORM
*   **Validation:** Zod
*   **Authentication:** Passport.js (with local strategy for username/password, session management)
*   **Password Hashing:** bcryptjs
*   **Job Queue:** BullMQ (producer side)
*   **Configuration:** dotenv
*   **Logging:** (To be defined - pino or similar recommended)

## Directory Structure (`server/src`)

```
src/
├── core/
│   ├── auth/         # Authentication middleware, strategies, types
│   ├── config/       # Environment variable loading and validation
│   ├── middleware/   # General Express middleware (error handling, logging, etc.)
│   ├── routes/       # API route definitions (organized by resource)
│   ├── jobs/         # Job definitions and processors (used by the worker)
│   └── utils/        # Common utility functions
├── db/
│   ├── migrations/   # Drizzle migration files
│   ├── schema.ts     # Drizzle schema definitions
│   └── index.ts      # Database connection setup
├── modules/
│   ├── ai/           # AI service, providers, prompts
│   ├── media/        # Media processing logic (uploads, text extraction)
│   ├── notes/        # Notes-related business logic
│   ├── study/        # Study tools logic (quiz, flashcards)
│   └── user/         # User profile logic
├── types/            # Shared backend-specific types
├── worker.ts         # BullMQ worker setup and job processing entry point
└── server.ts         # Express application setup and entry point
```

## Core Components

1.  **`server.ts`:**
    *   Initializes the Express application.
    *   Loads configuration.
    *   Connects to the database.
    *   Sets up core middleware (CORS, body-parser, session, Passport).
    *   Mounts API routers from `core/routes/`.
    *   Sets up global error handling middleware.
    *   Starts the HTTP server.

2.  **`core/config/index.ts`:**
    *   Uses `dotenv` to load environment variables from `.env`.
    *   Uses Zod to validate environment variables, ensuring required ones are present and correctly typed.
    *   Exports a typed configuration object.

3.  **`core/routes/`:**
    *   Organized by resource (e.g., `auth.route.ts`, `notes.route.ts`, `media.route.ts`).
    *   Each file defines an Express `Router`.
    *   Routes utilize controllers or inline handlers to process requests.
    *   Routes are protected using middleware from `core/auth/`. Example: `router.get('/', protect, notesController.getAllNotes);`
    *   A main router (`index.ts` in `core/routes`) aggregates all resource routers and applies a base path (e.g., `/api/v1`).

4.  **`core/auth/`:**
    *   **`protect.middleware.ts`:** Middleware to ensure a user is authenticated before allowing access to a route.
    *   **`passport.config.ts`:** Configures Passport.js strategies (e.g., `passport-local`) and serialization/deserialization.
    *   **`auth.types.ts`:** Defines types like `RequestWithUser` extending Express's Request type.

5.  **`db/`:**
    *   **`index.ts`:** Sets up the Drizzle client and database connection pool.
    *   **`schema.ts`:** Defines all database tables, columns, types, and relations using Drizzle schema syntax.
    *   **`migrations/`:** Contains SQL migration files generated by `drizzle-kit`.

6.  **Modules (`modules/*/`)**
    *   Contain domain-specific logic, often in services (e.g., `ai.service.ts`, `media.service.ts`).
    *   Services encapsulate business rules and interact with the database or external APIs.
    *   Route handlers often delegate tasks to these services.

7.  **`worker.ts`:**
    *   Although part of the `server` package, this runs as a separate process.
    *   Initializes a BullMQ `Worker` instance, connecting to Redis.
    *   Imports and defines processor functions for different job types (defined in `core/jobs/`).
    *   Handles job events (completed, failed).
    *   Requires its own instance of DB connection and potentially service instantiations.

## Request Lifecycle

1.  HTTP request arrives at the Express server.
2.  Goes through global middleware (CORS, body-parser, session).
3.  Matches a route defined in `core/routes/`.
4.  Authentication middleware (`protect`) runs if applied.
5.  Validation middleware (using Zod schemas, potentially) runs.
6.  Route handler/controller executes:
    *   Interacts with services in `modules/`.
    *   Services interact with the DB (`db/`) or external APIs.
    *   May enqueue jobs via BullMQ (`core/jobs/`).
7.  Handler sends a response (JSON) back to the client.
8.  Global error handler catches unhandled errors.

## Error Handling

*   Use `try...catch` blocks in async route handlers and services.
*   Define custom error classes (e.g., `ApiError`, `NotFoundError`) for specific scenarios.
*   A global error handling middleware (`core/middleware/errorHandler.ts`) catches errors, logs them, and sends standardized JSON error responses to the client.
*   Zod validation errors are caught and transformed into user-friendly error responses.

## Key Considerations

*   **State Management:** The API server should be largely stateless, relying on sessions/tokens for authentication state.
*   **Asynchronous Operations:** All I/O operations (DB queries, external API calls, job enqueuing) must be asynchronous (`async/await`).
*   **Security:** Input validation (Zod), authentication checks, CSRF protection (if needed), rate limiting are crucial.

## YouTube Pipeline: End-to-End Flow

The YouTube pipeline enables users to submit a YouTube video URL and receive structured, timestamped notes generated from the video's transcript.

### 1. Submission & Endpoint
- User submits a YouTube URL via the frontend.
- The backend exposes a POST `/api/media/youtube` endpoint that:
  - Validates the URL.
  - Creates a new `sources` record with the original YouTube URL and user ID.
  - Enqueues a processing job for the YouTube source.

### 2. Transcript Extraction
- The job pipeline uses a YouTube transcript extraction utility (e.g., `youtube-transcript` library).
- The utility fetches the transcript with **timestamps** for each segment/line/word (as supported by the API).
- The transcript is parsed into an array of `{ text, start, end }` objects.
- If the video is unavailable, has no captions, or is unsupported, the job fails gracefully and updates the source status with an error.

### 3. Data Model & Storage
- The original YouTube URL is stored in the `sources.originalUrl` field.
- The full transcript (with timestamps) is stored in the `sources.metadata.transcript` field (as an array of objects).
- The transcript is linked to the user via the `userId` field on the `sources` table.
- The processing status and error fields are updated throughout the pipeline.

### 4. AI Analysis & Note Generation
- Once the transcript is extracted, the pipeline enqueues the AI analysis job (same as for audio/text sources).
- The AI generates structured notes, visual opportunities, and study tools.
- The final note is linked to the original YouTube source and user.

### 5. Frontend Display
- The dashboard displays:
  - The original YouTube URL (with a link to the video).
  - The structured note content.
  - The full, timestamped transcript (optionally with clickable timestamps).
- Users can track progress/status and view errors if extraction fails.

### 6. Error Handling
- Handles:
  - Invalid or unsupported YouTube URLs.
  - Videos with no captions/transcript.
  - API/network errors.
- All errors are logged and surfaced to the user in a user-friendly way.

### 7. Example Transcript Data Structure
```json
[
  { "text": "Welcome to the video...", "start": 0.0, "end": 3.2 },
  { "text": "Today we'll learn...", "start": 3.2, "end": 7.5 },
  ...
]
```

This ensures that every YouTube note is fully traceable, timestamped, and user-linked, supporting advanced features like jumping to video segments or syncing with study tools. 